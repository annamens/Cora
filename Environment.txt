package com.seleniumfy.test.utils;

import static java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment;
import static java.lang.System.getProperty;
import static java.util.Arrays.asList;
import static javax.crypto.Cipher.DECRYPT_MODE;
import static javax.crypto.Cipher.ENCRYPT_MODE;
import static org.apache.commons.codec.binary.Base64.decodeBase64;
import static org.apache.commons.codec.binary.Base64.encodeBase64;
import java.awt.Rectangle;
import java.net.URL;
import java.security.spec.KeySpec;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.swing.UIManager;
import org.openqa.selenium.Point;

/**
 * @author Harry Soehalim - <a href="mailto:harry.soehalim@gmail.com">harry.soehalim@gmail.com</a>
 *         Copyright (c) 2012 by Harry Soehalim
 */
public class Environment {

    private static final String                 UNICODE_FORMAT  = "UTF8";
    private static final String                 algorithm       = "DESede";
    protected static String                     key             = "XXj7yuRzTpz9nNpy8zFmVaxM";
    public static long                          webdriverWait   = 30L;
    public static long                          jsScriptTime    = 2000L;
    public static boolean                       doBrowserResize = true;
    public static boolean                       useRemoteHub;
    public static URL                           remoteHubUrl;
    public static boolean                       useSauceLabs;
    public static URL                           sauceUrl;
    public static String                        sauceUser;
    public static String                        sauceKey;
    public static String                        sauceTunnel;
    public static Map <String, String>          sauceOptions    = new HashMap <> ();
    public static boolean                       isRemoteTest;
    public static int                           threads;
    public static String                        parallel;
    public static int                           browserWidth    = 1000;
    public static int                           browserHeight   = 700;
    public static BrowserName                   browserName;
    public static String                        browserVersion;
    public static Platform                      platform;
    public static String                        resolution;
    public static String                        os;
    public static String                        projectVersion;
    public static List <String>                 tags;
    public static ConcurrentLinkedQueue <Point> windowPositions = new ConcurrentLinkedQueue <Point> ();

    public static void initialization () throws Exception {
        webdriverWait = Long.valueOf (getProperty ("test.webdriver.wait", "10"));
        parallel = getProperty ("parallel", "methods");
        threads = Integer.parseInt (getProperty ("test.threads", "1"));
        useRemoteHub = Boolean.valueOf (getProperty ("useRemoteHub", "false"));
        useSauceLabs = Boolean.valueOf (getProperty ("useSauceLabs", "false"));
        isRemoteTest = useRemoteHub || useSauceLabs;
        if (isRemoteTest)
            webdriverWait *= 3; // everything runs slower on remote hub
        else {
            setBrowserSizeAndPosition ();
            if (getProperty ("browserWidth") != null)
                browserWidth = Integer.parseInt (getProperty ("browserWidth"));
            if (getProperty ("browserHeight") != null)
                browserHeight = Integer.parseInt (getProperty ("browserHeight"));
        }
        remoteHubUrl = new URL ("http://10.248.3.139:4444/wd/hub");
        sauceUser = getProperty ("sauce.user");
        sauceKey = getProperty ("sauce.key");
        sauceTunnel = getProperty ("sauce.tunnel", sauceUser);
        sauceUrl = new URL ("https://ondemand.saucelabs.com/wd/hub");

        os = getProperty ("os.name").toLowerCase ();
        projectVersion = getProperty ("project.version");
        if (getProperty ("browserName") != null)
            browserName = BrowserName.valueOf (getProperty ("browserName"));
        browserVersion = getProperty ("browserVersion");
        if (getProperty ("platform") != null)
            platform = Platform.valueOf (getProperty ("platform"));
        resolution = getProperty ("resolution");
        tags = getProperty ("test.tags") != null ? asList (getProperty ("test.tags").split (",")) : null;
    }

    private static void setBrowserSizeAndPosition () throws Exception {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
        Rectangle bounds = getLocalGraphicsEnvironment ().getMaximumWindowBounds ();
        int maxWidth = 1100;
        int screenWidth = bounds.width;
        int screenHeight = bounds.height;
        int left = bounds.x;
        int top = bounds.y;
        int rows = 1;
        int columns = 1;
        if (threads > 1)
            rows = 2;
        if (threads > 2)
            columns = 2;
        if (threads > 4)
            columns = 3;
        if (threads > 6)
            rows = 3;
        if (threads > 9)
            columns = 4;
        if (threads > 12)
            rows = 4;
        browserWidth = screenWidth / columns;
        if (browserWidth > maxWidth)
            browserWidth = maxWidth;

        browserHeight = screenHeight / rows;
        for (int i = 0; i < threads; i++) {
            if (i > 0 && i % columns == 0) {
                left = bounds.x;
                top += browserHeight;
            }
            windowPositions.add (new Point (left, top));
            left += browserWidth;
        }
    }

    public static enum BrowserName {
        chrome ("chrome"), ff ("firefox"), edge ("edge"), ie ("internet explorer"), safari ("safari");

        public String value;

        private BrowserName (String value) {
            this.value = value;
        }
    }

    public static enum Platform {
        win81 ("Windows 8.1"),
        win8 ("Windows 8"),
        win10 ("Windows 10"),
        osx15 ("macOS 10.15"),
        osx14 ("macOS 10.14"),
        osx13 ("macOS 10.13");

        public String value;

        private Platform (String value) {
            this.value = value;
        }

        public static Platform getPlatform (String value) {
            return EnumSet.allOf (Platform.class).parallelStream ().filter (b -> {
                return b.value.equals (value);
            }).findAny ().orElse (null);
        }
    }

    protected static String decrypt (String encryptedString) {
        try {
            KeySpec kSpec = new DESedeKeySpec (key.getBytes (UNICODE_FORMAT));
            Cipher cipher = Cipher.getInstance (algorithm);
            cipher.init (DECRYPT_MODE, SecretKeyFactory.getInstance (algorithm).generateSecret (kSpec));
            return new String (cipher.doFinal (decodeBase64 (encryptedString)));
        } catch (Exception e) {
            throw new RuntimeException (e);
        }
    }

    protected static String encrypt (String unencryptedString) {
        try {
            KeySpec kSpec = new DESedeKeySpec (key.getBytes (UNICODE_FORMAT));
            SecretKeyFactory skf = SecretKeyFactory.getInstance (algorithm);
            Cipher cipher = Cipher.getInstance (algorithm);
            cipher.init (ENCRYPT_MODE, skf.generateSecret (kSpec));
            byte[] encryptedText = cipher.doFinal (unencryptedString.getBytes (UNICODE_FORMAT));
            return new String (encodeBase64 (encryptedText));
        } catch (Exception e) {
            throw new RuntimeException (e);
        }
    }
}
